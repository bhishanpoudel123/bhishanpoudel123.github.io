
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pandas Quiz</title>
    <link rel="stylesheet" href="../styles.css">
</head>
<body>
    <div class="container">
        <h1>Pandas Quiz</h1>
        <div class="quiz-container">
    
            <div class="question" id="q1">
                <h3>Question 1: Which method efficiently applies a function along an axis of a DataFrame?</h3>
                <div class="options">
                    <div class="option"><input type="radio" name="q1" id="q1o0" value="0"><label for="q1o0">df.map(func)</label></div>
<div class="option"><input type="radio" name="q1" id="q1o1" value="1"><label for="q1o1">df.apply(func, axis=0)</label></div>
<div class="option"><input type="radio" name="q1" id="q1o2" value="2"><label for="q1o2">df.transform(func)</label></div>
<div class="option"><input type="radio" name="q1" id="q1o3" value="3"><label for="q1o3">df.aggregate(func)</label></div>
                </div>
                <div class="answer hidden">
                    <p><strong>Answer:</strong> df.apply(func, axis=0)</p>
                    <p><strong>Explanation:</strong> The apply() method allows applying a function along an axis (rows or columns) of a DataFrame.</p>
                    
                </div>
                <button class="show-answer">Show Answer</button>
            </div>
        
            <div class="question" id="q2">
                <h3>Question 2: What's the correct way to merge two DataFrames on multiple columns?</h3>
                <div class="options">
                    <div class="option"><input type="radio" name="q2" id="q2o0" value="0"><label for="q2o0">pd.merge(df1, df2, on=['col1', 'col2'])</label></div>
<div class="option"><input type="radio" name="q2" id="q2o1" value="1"><label for="q2o1">pd.join(df1, df2, keys=['col1', 'col2'])</label></div>
<div class="option"><input type="radio" name="q2" id="q2o2" value="2"><label for="q2o2">df1.merge(df2, how='inner', left_on=['col1', 'col2'], right_on=['col1', 'col2'])</label></div>
<div class="option"><input type="radio" name="q2" id="q2o3" value="3"><label for="q2o3">Both A and C</label></div>
                </div>
                <div class="answer hidden">
                    <p><strong>Answer:</strong> Both A and C</p>
                    <p><strong>Explanation:</strong> Both pd.merge() and DataFrame.merge() methods can merge on multiple columns specified as lists.</p>
                    
                </div>
                <button class="show-answer">Show Answer</button>
            </div>
        
            <div class="question" id="q3">
                <h3>Question 3: How do you handle missing values in a DataFrame column?</h3>
                <div class="options">
                    <div class="option"><input type="radio" name="q3" id="q3o0" value="0"><label for="q3o0">df['column'].fillna(0)</label></div>
<div class="option"><input type="radio" name="q3" id="q3o1" value="1"><label for="q3o1">df['column'].dropna()</label></div>
<div class="option"><input type="radio" name="q3" id="q3o2" value="2"><label for="q3o2">df['column'].replace(np.nan, 0)</label></div>
<div class="option"><input type="radio" name="q3" id="q3o3" value="3"><label for="q3o3">All of the above</label></div>
                </div>
                <div class="answer hidden">
                    <p><strong>Answer:</strong> All of the above</p>
                    <p><strong>Explanation:</strong> All listed methods can handle missing values: fillna() replaces NaNs, dropna() removes rows with NaNs, and replace() can substitute NaNs with specified values.</p>
                    
                </div>
                <button class="show-answer">Show Answer</button>
            </div>
        
            <div class="question" id="q4">
                <h3>Question 4: What does the method `groupby().agg()` allow you to do?</h3>
                <div class="options">
                    <div class="option"><input type="radio" name="q4" id="q4o0" value="0"><label for="q4o0">Group data and apply a single aggregation function</label></div>
<div class="option"><input type="radio" name="q4" id="q4o1" value="1"><label for="q4o1">Group data and apply different aggregation functions to different columns</label></div>
<div class="option"><input type="radio" name="q4" id="q4o2" value="2"><label for="q4o2">Group data and apply multiple aggregation functions to the same column</label></div>
<div class="option"><input type="radio" name="q4" id="q4o3" value="3"><label for="q4o3">All of the above</label></div>
                </div>
                <div class="answer hidden">
                    <p><strong>Answer:</strong> All of the above</p>
                    <p><strong>Explanation:</strong> The agg() method is versatile and can apply single or multiple functions to grouped data, either to all columns or selectively.</p>
                    
                </div>
                <button class="show-answer">Show Answer</button>
            </div>
        
            <div class="question" id="q5">
                <h3>Question 5: Which of the following transforms a DataFrame to a long format?</h3>
                <div class="options">
                    <div class="option"><input type="radio" name="q5" id="q5o0" value="0"><label for="q5o0">df.stack()</label></div>
<div class="option"><input type="radio" name="q5" id="q5o1" value="1"><label for="q5o1">df.melt()</label></div>
<div class="option"><input type="radio" name="q5" id="q5o2" value="2"><label for="q5o2">pd.wide_to_long(df)</label></div>
<div class="option"><input type="radio" name="q5" id="q5o3" value="3"><label for="q5o3">All of the above</label></div>
                </div>
                <div class="answer hidden">
                    <p><strong>Answer:</strong> All of the above</p>
                    <p><strong>Explanation:</strong> stack(), melt(), and wide_to_long() all convert data from wide format to long format, albeit with different approaches and parameters.</p>
                    
                </div>
                <button class="show-answer">Show Answer</button>
            </div>
        
            <div class="question" id="q6">
                <h3>Question 6: How can you efficiently select rows where a column value meets a complex condition?</h3>
                <div class="options">
                    <div class="option"><input type="radio" name="q6" id="q6o0" value="0"><label for="q6o0">df.loc[df['column'] > 5 & df['column'] < 10]</label></div>
<div class="option"><input type="radio" name="q6" id="q6o1" value="1"><label for="q6o1">df.loc[(df['column'] > 5) & (df['column'] < 10)]</label></div>
<div class="option"><input type="radio" name="q6" id="q6o2" value="2"><label for="q6o2">df.query('column > 5 and column < 10')</label></div>
<div class="option"><input type="radio" name="q6" id="q6o3" value="3"><label for="q6o3">Both B and C</label></div>
                </div>
                <div class="answer hidden">
                    <p><strong>Answer:</strong> Both B and C</p>
                    <p><strong>Explanation:</strong> Both loc with boolean indexing (with proper parentheses) and query() method can filter data based on complex conditions.</p>
                    
                </div>
                <button class="show-answer">Show Answer</button>
            </div>
        
            <div class="question" id="q7">
                <h3>Question 7: What's the most efficient way to calculate a rolling 7-day average of a time series?</h3>
                <div class="options">
                    <div class="option"><input type="radio" name="q7" id="q7o0" value="0"><label for="q7o0">df['rolling_avg'] = df['value'].rolling(window=7).mean()</label></div>
<div class="option"><input type="radio" name="q7" id="q7o1" value="1"><label for="q7o1">df['rolling_avg'] = df['value'].resample('7D').mean()</label></div>
<div class="option"><input type="radio" name="q7" id="q7o2" value="2"><label for="q7o2">df['rolling_avg'] = df.groupby(pd.Grouper(freq='7D'))['value'].transform('mean')</label></div>
<div class="option"><input type="radio" name="q7" id="q7o3" value="3"><label for="q7o3">df['rolling_avg'] = pd.rolling_mean(df['value'], window=7)</label></div>
                </div>
                <div class="answer hidden">
                    <p><strong>Answer:</strong> df['rolling_avg'] = df['value'].rolling(window=7).mean()</p>
                    <p><strong>Explanation:</strong> The rolling() method with a window of 7 followed by mean() calculates a rolling average over a 7-period window.</p>
                    
                </div>
                <button class="show-answer">Show Answer</button>
            </div>
        
            <div class="question" id="q8">
                <h3>Question 8: How do you perform a pivot operation in pandas?</h3>
                <div class="options">
                    <div class="option"><input type="radio" name="q8" id="q8o0" value="0"><label for="q8o0">df.pivot(index='A', columns='B', values='C')</label></div>
<div class="option"><input type="radio" name="q8" id="q8o1" value="1"><label for="q8o1">pd.pivot_table(df, index='A', columns='B', values='C')</label></div>
<div class="option"><input type="radio" name="q8" id="q8o2" value="2"><label for="q8o2">df.pivot_table(index='A', columns='B', values='C')</label></div>
<div class="option"><input type="radio" name="q8" id="q8o3" value="3"><label for="q8o3">All of the above</label></div>
                </div>
                <div class="answer hidden">
                    <p><strong>Answer:</strong> All of the above</p>
                    <p><strong>Explanation:</strong> All three methods can perform pivot operations, with pivot_table being more flexible as it can aggregate duplicate entries.</p>
                    
                </div>
                <button class="show-answer">Show Answer</button>
            </div>
        
            <div class="question" id="q9">
                <h3>Question 9: Which method can reshape a DataFrame by stacking column labels to rows?</h3>
                <div class="options">
                    <div class="option"><input type="radio" name="q9" id="q9o0" value="0"><label for="q9o0">df.unstack()</label></div>
<div class="option"><input type="radio" name="q9" id="q9o1" value="1"><label for="q9o1">df.pivot()</label></div>
<div class="option"><input type="radio" name="q9" id="q9o2" value="2"><label for="q9o2">df.stack()</label></div>
<div class="option"><input type="radio" name="q9" id="q9o3" value="3"><label for="q9o3">df.melt()</label></div>
                </div>
                <div class="answer hidden">
                    <p><strong>Answer:</strong> df.stack()</p>
                    <p><strong>Explanation:</strong> stack() method pivots the columns of a DataFrame to become the innermost index level, creating a Series with a MultiIndex.</p>
                    
                </div>
                <button class="show-answer">Show Answer</button>
            </div>
        
            <div class="question" id="q10">
                <h3>Question 10: How do you efficiently concatenate many DataFrames with identical columns?</h3>
                <div class="options">
                    <div class="option"><input type="radio" name="q10" id="q10o0" value="0"><label for="q10o0">pd.join([df1, df2, df3])</label></div>
<div class="option"><input type="radio" name="q10" id="q10o1" value="1"><label for="q10o1">pd.merge([df1, df2, df3])</label></div>
<div class="option"><input type="radio" name="q10" id="q10o2" value="2"><label for="q10o2">pd.concat([df1, df2, df3])</label></div>
<div class="option"><input type="radio" name="q10" id="q10o3" value="3"><label for="q10o3">df1.append([df2, df3])</label></div>
                </div>
                <div class="answer hidden">
                    <p><strong>Answer:</strong> pd.concat([df1, df2, df3])</p>
                    <p><strong>Explanation:</strong> pd.concat() is designed to efficiently concatenate pandas objects along a particular axis with optional set logic.</p>
                    
                </div>
                <button class="show-answer">Show Answer</button>
            </div>
        
            <div class="question" id="q11">
                <h3>Question 11: What's the correct way to create a DatetimeIndex from a column containing date strings?</h3>
                <div class="options">
                    <div class="option"><input type="radio" name="q11" id="q11o0" value="0"><label for="q11o0">pd.to_datetime(df['date_col'])</label></div>
<div class="option"><input type="radio" name="q11" id="q11o1" value="1"><label for="q11o1">df.set_index(pd.to_datetime(df['date_col']))</label></div>
<div class="option"><input type="radio" name="q11" id="q11o2" value="2"><label for="q11o2">df.set_index('date_col', inplace=True); df.index = pd.to_datetime(df.index)</label></div>
<div class="option"><input type="radio" name="q11" id="q11o3" value="3"><label for="q11o3">All of the above</label></div>
                </div>
                <div class="answer hidden">
                    <p><strong>Answer:</strong> All of the above</p>
                    <p><strong>Explanation:</strong> All methods will correctly convert date strings to datetime objects, with different approaches to setting them as the index.</p>
                    
                </div>
                <button class="show-answer">Show Answer</button>
            </div>
        
            <div class="question" id="q12">
                <h3>Question 12: Which method performs a cross-tabulation of two factors?</h3>
                <div class="options">
                    <div class="option"><input type="radio" name="q12" id="q12o0" value="0"><label for="q12o0">pd.crosstab(df['A'], df['B'])</label></div>
<div class="option"><input type="radio" name="q12" id="q12o1" value="1"><label for="q12o1">df.pivot_table(index='A', columns='B', aggfunc='count')</label></div>
<div class="option"><input type="radio" name="q12" id="q12o2" value="2"><label for="q12o2">df.groupby(['A', 'B']).size().unstack()</label></div>
<div class="option"><input type="radio" name="q12" id="q12o3" value="3"><label for="q12o3">All of the above</label></div>
                </div>
                <div class="answer hidden">
                    <p><strong>Answer:</strong> All of the above</p>
                    <p><strong>Explanation:</strong> All methods can create cross-tabulations, though crosstab() is specifically designed for this purpose.</p>
                    
                </div>
                <button class="show-answer">Show Answer</button>
            </div>
        
            <div class="question" id="q13">
                <h3>Question 13: How do you calculate cumulative statistics in pandas?</h3>
                <div class="options">
                    <div class="option"><input type="radio" name="q13" id="q13o0" value="0"><label for="q13o0">df.cumsum(), df.cumprod(), df.cummax(), df.cummin()</label></div>
<div class="option"><input type="radio" name="q13" id="q13o1" value="1"><label for="q13o1">df.rolling().sum(), df.rolling().prod(), df.rolling().max(), df.rolling().min()</label></div>
<div class="option"><input type="radio" name="q13" id="q13o2" value="2"><label for="q13o2">df.expanding().sum(), df.expanding().prod(), df.expanding().max(), df.expanding().min()</label></div>
<div class="option"><input type="radio" name="q13" id="q13o3" value="3"><label for="q13o3">df.aggregate(['sum', 'prod', 'max', 'min'])</label></div>
                </div>
                <div class="answer hidden">
                    <p><strong>Answer:</strong> df.cumsum(), df.cumprod(), df.cummax(), df.cummin()</p>
                    <p><strong>Explanation:</strong> The cum- methods (cumsum, cumprod, cummax, cummin) calculate cumulative statistics along an axis.</p>
                    
                </div>
                <button class="show-answer">Show Answer</button>
            </div>
        
            <div class="question" id="q14">
                <h3>Question 14: Which approach efficiently calculates the difference between consecutive rows in a DataFrame?</h3>
                <div class="options">
                    <div class="option"><input type="radio" name="q14" id="q14o0" value="0"><label for="q14o0">df - df.shift(1)</label></div>
<div class="option"><input type="radio" name="q14" id="q14o1" value="1"><label for="q14o1">df.diff()</label></div>
<div class="option"><input type="radio" name="q14" id="q14o2" value="2"><label for="q14o2">df.rolling(2).apply(lambda x: x.iloc[1] - x.iloc[0])</label></div>
<div class="option"><input type="radio" name="q14" id="q14o3" value="3"><label for="q14o3">Both A and B</label></div>
                </div>
                <div class="answer hidden">
                    <p><strong>Answer:</strong> Both A and B</p>
                    <p><strong>Explanation:</strong> Both subtracting a shifted DataFrame and using diff() calculate element-wise differences between consecutive rows.</p>
                    
                </div>
                <button class="show-answer">Show Answer</button>
            </div>
        
            <div class="question" id="q15">
                <h3>Question 15: How do you create a MultiIndex DataFrame from scratch?</h3>
                <div class="options">
                    <div class="option"><input type="radio" name="q15" id="q15o0" value="0"><label for="q15o0">pd.DataFrame(data, index=pd.MultiIndex.from_tuples([('A',1), ('A',2), ('B',1), ('B',2)]))</label></div>
<div class="option"><input type="radio" name="q15" id="q15o1" value="1"><label for="q15o1">pd.DataFrame(data, index=pd.MultiIndex.from_product([['A', 'B'], [1, 2]]))</label></div>
<div class="option"><input type="radio" name="q15" id="q15o2" value="2"><label for="q15o2">pd.DataFrame(data, index=pd.MultiIndex.from_arrays([['A', 'A', 'B', 'B'], [1, 2, 1, 2]]))</label></div>
<div class="option"><input type="radio" name="q15" id="q15o3" value="3"><label for="q15o3">All of the above</label></div>
                </div>
                <div class="answer hidden">
                    <p><strong>Answer:</strong> All of the above</p>
                    <p><strong>Explanation:</strong> All three methods create equivalent MultiIndex objects using different approaches: from_tuples, from_product, and from_arrays.</p>
                    
                </div>
                <button class="show-answer">Show Answer</button>
            </div>
        
            <div class="question" id="q16">
                <h3>Question 16: Which method is most appropriate for performing complex string operations on DataFrame columns?</h3>
                <div class="options">
                    <div class="option"><input type="radio" name="q16" id="q16o0" value="0"><label for="q16o0">df['col'].apply(lambda x: x.upper())</label></div>
<div class="option"><input type="radio" name="q16" id="q16o1" value="1"><label for="q16o1">df['col'].str.upper()</label></div>
<div class="option"><input type="radio" name="q16" id="q16o2" value="2"><label for="q16o2">df['col'].map(str.upper)</label></div>
<div class="option"><input type="radio" name="q16" id="q16o3" value="3"><label for="q16o3">All of the above work, but B is most efficient</label></div>
                </div>
                <div class="answer hidden">
                    <p><strong>Answer:</strong> All of the above work, but B is most efficient</p>
                    <p><strong>Explanation:</strong> While all methods can transform strings, the .str accessor provides vectorized string functions that are generally more efficient than apply() or map().</p>
                    
                </div>
                <button class="show-answer">Show Answer</button>
            </div>
        
            <div class="question" id="q17">
                <h3>Question 17: What's the best way to compute percentiles for grouped data?</h3>
                <div class="options">
                    <div class="option"><input type="radio" name="q17" id="q17o0" value="0"><label for="q17o0">df.groupby('group').quantile([0.25, 0.5, 0.75])</label></div>
<div class="option"><input type="radio" name="q17" id="q17o1" value="1"><label for="q17o1">df.groupby('group').agg(lambda x: np.percentile(x, [25, 50, 75]))</label></div>
<div class="option"><input type="radio" name="q17" id="q17o2" value="2"><label for="q17o2">df.groupby('group').describe(percentiles=[0.25, 0.5, 0.75])</label></div>
<div class="option"><input type="radio" name="q17" id="q17o3" value="3"><label for="q17o3">Both A and C</label></div>
                </div>
                <div class="answer hidden">
                    <p><strong>Answer:</strong> Both A and C</p>
                    <p><strong>Explanation:</strong> Both quantile() and describe() can compute percentiles for grouped data, with describe() providing additional statistics. For option B, While this approach uses the right function (numpy's percentile), there's an issue with how it's implemented in the context of pandas GroupBy. This would likely raise errors because the lambda function returns arrays rather than scalars, which is problematic for the standard aggregation pipeline.</p>
                    
                </div>
                <button class="show-answer">Show Answer</button>
            </div>
        
            <div class="question" id="q18">
                <h3>Question 18: How do you efficiently implement a custom aggregation function that requires the entire group?</h3>
                <div class="options">
                    <div class="option"><input type="radio" name="q18" id="q18o0" value="0"><label for="q18o0">df.groupby('group').agg(custom_func)</label></div>
<div class="option"><input type="radio" name="q18" id="q18o1" value="1"><label for="q18o1">df.groupby('group').apply(custom_func)</label></div>
<div class="option"><input type="radio" name="q18" id="q18o2" value="2"><label for="q18o2">df.groupby('group').transform(custom_func)</label></div>
<div class="option"><input type="radio" name="q18" id="q18o3" value="3"><label for="q18o3">df.groupby('group').aggregate(custom_func)</label></div>
                </div>
                <div class="answer hidden">
                    <p><strong>Answer:</strong> df.groupby('group').apply(custom_func)</p>
                    <p><strong>Explanation:</strong> apply() is designed for operations that need the entire group as a DataFrame, whereas agg() is better for operations that can be vectorized.</p>
                    
                </div>
                <button class="show-answer">Show Answer</button>
            </div>
        
            <div class="question" id="q19">
                <h3>Question 19: What's the most memory-efficient way to read a large CSV file with pandas?</h3>
                <div class="options">
                    <div class="option"><input type="radio" name="q19" id="q19o0" value="0"><label for="q19o0">pd.read_csv('file.csv', nrows=1000)</label></div>
<div class="option"><input type="radio" name="q19" id="q19o1" value="1"><label for="q19o1">pd.read_csv('file.csv', chunksize=1000)</label></div>
<div class="option"><input type="radio" name="q19" id="q19o2" value="2"><label for="q19o2">pd.read_csv('file.csv', usecols=['needed_col1', 'needed_col2'])</label></div>
<div class="option"><input type="radio" name="q19" id="q19o3" value="3"><label for="q19o3">pd.read_csv('file.csv', dtype={'col1': 'category', 'col2': 'int8'})</label></div>
                </div>
                <div class="answer hidden">
                    <p><strong>Answer:</strong> pd.read_csv('file.csv', dtype={'col1': 'category', 'col2': 'int8'})</p>
                    <p><strong>Explanation:</strong> Specifying appropriate dtypes, especially using 'category' for string columns with repeated values, significantly reduces memory usage.</p>
                    
                </div>
                <button class="show-answer">Show Answer</button>
            </div>
        
            <div class="question" id="q20">
                <h3>Question 20: Which method is correct for resampling time series data to monthly frequency?</h3>
                <div class="options">
                    <div class="option"><input type="radio" name="q20" id="q20o0" value="0"><label for="q20o0">df.resample('M').mean()</label></div>
<div class="option"><input type="radio" name="q20" id="q20o1" value="1"><label for="q20o1">df.groupby(pd.Grouper(freq='M')).mean()</label></div>
<div class="option"><input type="radio" name="q20" id="q20o2" value="2"><label for="q20o2">df.asfreq('M')</label></div>
<div class="option"><input type="radio" name="q20" id="q20o3" value="3"><label for="q20o3">Both A and B</label></div>
                </div>
                <div class="answer hidden">
                    <p><strong>Answer:</strong> Both A and B</p>
                    <p><strong>Explanation:</strong> Both resample() and groupby() with Grouper can aggregate time series data to monthly frequency, though asfreq() only changes frequency without aggregation.</p>
                    
                </div>
                <button class="show-answer">Show Answer</button>
            </div>
        
            <div class="question" id="q21">
                <h3>Question 21: How do you efficiently identify and remove duplicate rows in a DataFrame?</h3>
                <div class="options">
                    <div class="option"><input type="radio" name="q21" id="q21o0" value="0"><label for="q21o0">df[~df.duplicated()]</label></div>
<div class="option"><input type="radio" name="q21" id="q21o1" value="1"><label for="q21o1">df.drop_duplicates()</label></div>
<div class="option"><input type="radio" name="q21" id="q21o2" value="2"><label for="q21o2">df.loc[~df.index.duplicated()]</label></div>
<div class="option"><input type="radio" name="q21" id="q21o3" value="3"><label for="q21o3">Both A and B</label></div>
                </div>
                <div class="answer hidden">
                    <p><strong>Answer:</strong> Both A and B</p>
                    <p><strong>Explanation:</strong> Both df[~df.duplicated()] and df.drop_duplicates() remove duplicate rows, with the latter being more readable and offering more options.</p>
                    
                </div>
                <button class="show-answer">Show Answer</button>
            </div>
        
            <div class="question" id="q22">
                <h3>Question 22: Which method is most efficient for applying a custom function to a DataFrame that returns a scalar?</h3>
                <div class="options">
                    <div class="option"><input type="radio" name="q22" id="q22o0" value="0"><label for="q22o0">df.pipe(custom_func)</label></div>
<div class="option"><input type="radio" name="q22" id="q22o1" value="1"><label for="q22o1">df.transform(custom_func)</label></div>
<div class="option"><input type="radio" name="q22" id="q22o2" value="2"><label for="q22o2">df.apply(custom_func)</label></div>
<div class="option"><input type="radio" name="q22" id="q22o3" value="3"><label for="q22o3">custom_func(df)</label></div>
                </div>
                <div class="answer hidden">
                    <p><strong>Answer:</strong> df.pipe(custom_func)</p>
                    <p><strong>Explanation:</strong> pipe() is designed for functions that take and return a DataFrame, creating readable method chains when applying multiple functions.</p>
                    
                </div>
                <button class="show-answer">Show Answer</button>
            </div>
        
            <div class="question" id="q23">
                <h3>Question 23: How do you sample data from a DataFrame with weights?</h3>
                <div class="options">
                    <div class="option"><input type="radio" name="q23" id="q23o0" value="0"><label for="q23o0">df.sample(n=5, weights='probability_column')</label></div>
<div class="option"><input type="radio" name="q23" id="q23o1" value="1"><label for="q23o1">df.sample(frac=0.1, weights=df['probability_column'])</label></div>
<div class="option"><input type="radio" name="q23" id="q23o2" value="2"><label for="q23o2">df.sample(n=5, weights=df['probability_column']/df['probability_column'].sum())</label></div>
<div class="option"><input type="radio" name="q23" id="q23o3" value="3"><label for="q23o3">Both B and C</label></div>
                </div>
                <div class="answer hidden">
                    <p><strong>Answer:</strong> Both B and C</p>
                    <p><strong>Explanation:</strong> Both approaches correctly sample with weights, though weights don't need to be normalized as pandas normalizes them internally.</p>
                    
                </div>
                <button class="show-answer">Show Answer</button>
            </div>
        
            <div class="question" id="q24">
                <h3>Question 24: What's the correct way to use the pd.cut() function for binning continuous data?</h3>
                <div class="options">
                    <div class="option"><input type="radio" name="q24" id="q24o0" value="0"><label for="q24o0">pd.cut(df['age'], bins=[0, 18, 35, 60, 100], labels=['Child', 'Young', 'Middle', 'Senior'])</label></div>
<div class="option"><input type="radio" name="q24" id="q24o1" value="1"><label for="q24o1">pd.cut(df['age'], bins=4, labels=['Q1', 'Q2', 'Q3', 'Q4'])</label></div>
<div class="option"><input type="radio" name="q24" id="q24o2" value="2"><label for="q24o2">pd.qcut(df['age'], q=4, labels=['Q1', 'Q2', 'Q3', 'Q4'])</label></div>
<div class="option"><input type="radio" name="q24" id="q24o3" value="3"><label for="q24o3">All of the above are valid uses</label></div>
                </div>
                <div class="answer hidden">
                    <p><strong>Answer:</strong> All of the above are valid uses</p>
                    <p><strong>Explanation:</strong> All approaches are valid: using explicit bin edges, equal-width bins (cut), or equal-frequency bins (qcut).</p>
                    
                </div>
                <button class="show-answer">Show Answer</button>
            </div>
        
            <div class="question" id="q25">
                <h3>Question 25: How do you efficiently perform a custom window operation in pandas?</h3>
                <div class="options">
                    <div class="option"><input type="radio" name="q25" id="q25o0" value="0"><label for="q25o0">df.rolling(window=3).apply(custom_func, raw=True)</label></div>
<div class="option"><input type="radio" name="q25" id="q25o1" value="1"><label for="q25o1">df.rolling(window=3).apply(custom_func)</label></div>
<div class="option"><input type="radio" name="q25" id="q25o2" value="2"><label for="q25o2">df.apply(lambda x: [custom_func(x[i:i+3]) for i in range(len(x)-2)])</label></div>
<div class="option"><input type="radio" name="q25" id="q25o3" value="3"><label for="q25o3">Both A and B</label></div>
                </div>
                <div class="answer hidden">
                    <p><strong>Answer:</strong> Both A and B</p>
                    <p><strong>Explanation:</strong> Both approaches work for custom window operations, but using raw=True can be more efficient for numerical operations by passing a NumPy array instead of a Series.</p>
                    
                </div>
                <button class="show-answer">Show Answer</button>
            </div>
        
            <div class="question" id="q26">
                <h3>Question 26: Which approach can create a lagged feature in a time series DataFrame?</h3>
                <div class="options">
                    <div class="option"><input type="radio" name="q26" id="q26o0" value="0"><label for="q26o0">df['lagged'] = df['value'].shift(1)</label></div>
<div class="option"><input type="radio" name="q26" id="q26o1" value="1"><label for="q26o1">df['lagged'] = df['value'].shift(-1)</label></div>
<div class="option"><input type="radio" name="q26" id="q26o2" value="2"><label for="q26o2">df['lagged'] = df['value'].rolling(window=2).apply(lambda x: x.iloc[0])</label></div>
<div class="option"><input type="radio" name="q26" id="q26o3" value="3"><label for="q26o3">Both A and B</label></div>
                </div>
                <div class="answer hidden">
                    <p><strong>Answer:</strong> Both A and B</p>
                    <p><strong>Explanation:</strong> shift(1) creates a lag (past values), while shift(-1) creates a lead (future values), both useful for time series analysis.</p>
                    
                </div>
                <button class="show-answer">Show Answer</button>
            </div>
        
            <div class="question" id="q27">
                <h3>Question 27: What's the best way to explode a DataFrame column containing lists into multiple rows?</h3>
                <div class="options">
                    <div class="option"><input type="radio" name="q27" id="q27o0" value="0"><label for="q27o0">pd.DataFrame([[i, x] for i, y in df['list_col'].iteritems() for x in y])</label></div>
<div class="option"><input type="radio" name="q27" id="q27o1" value="1"><label for="q27o1">df.explode('list_col')</label></div>
<div class="option"><input type="radio" name="q27" id="q27o2" value="2"><label for="q27o2">df.assign(list_col=df['list_col']).explode('list_col')</label></div>
<div class="option"><input type="radio" name="q27" id="q27o3" value="3"><label for="q27o3">Both B and C</label></div>
                </div>
                <div class="answer hidden">
                    <p><strong>Answer:</strong> Both B and C</p>
                    <p><strong>Explanation:</strong> explode() transforms each element of a list-like column into a row, with the original index duplicated as needed.</p>
                    
                </div>
                <button class="show-answer">Show Answer</button>
            </div>
        
            <div class="question" id="q28">
                <h3>Question 28: How do you efficiently compute a weighted mean in pandas?</h3>
                <div class="options">
                    <div class="option"><input type="radio" name="q28" id="q28o0" value="0"><label for="q28o0">(df['value'] * df['weight']).sum() / df['weight'].sum()</label></div>
<div class="option"><input type="radio" name="q28" id="q28o1" value="1"><label for="q28o1">df['value'].mean(weights=df['weight'])</label></div>
<div class="option"><input type="radio" name="q28" id="q28o2" value="2"><label for="q28o2">np.average(df['value'], weights=df['weight'])</label></div>
<div class="option"><input type="radio" name="q28" id="q28o3" value="3"><label for="q28o3">Both A and C</label></div>
                </div>
                <div class="answer hidden">
                    <p><strong>Answer:</strong> Both A and C</p>
                    <p><strong>Explanation:</strong> Both manually computing weighted mean and using np.average() work efficiently, though pandas Series doesn't have a weights parameter for mean().</p>
                    
                </div>
                <button class="show-answer">Show Answer</button>
            </div>
        
            <div class="question" id="q29">
                <h3>Question 29: Which method correctly identifies the top-k values in each group?</h3>
                <div class="options">
                    <div class="option"><input type="radio" name="q29" id="q29o0" value="0"><label for="q29o0">df.groupby('group')['value'].nlargest(k)</label></div>
<div class="option"><input type="radio" name="q29" id="q29o1" value="1"><label for="q29o1">df.groupby('group').apply(lambda x: x.nlargest(k, 'value'))</label></div>
<div class="option"><input type="radio" name="q29" id="q29o2" value="2"><label for="q29o2">df.sort_values('value', ascending=False).groupby('group').head(k)</label></div>
<div class="option"><input type="radio" name="q29" id="q29o3" value="3"><label for="q29o3">All of the above</label></div>
                </div>
                <div class="answer hidden">
                    <p><strong>Answer:</strong> All of the above</p>
                    <p><strong>Explanation:</strong> All three methods can get the top-k values within each group, with different syntax but similar results.</p>
                    
                </div>
                <button class="show-answer">Show Answer</button>
            </div>
        
            <div class="question" id="q30">
                <h3>Question 30: What's the best way to add a new column based on a categorical mapping of an existing column?</h3>
                <div class="options">
                    <div class="option"><input type="radio" name="q30" id="q30o0" value="0"><label for="q30o0">df['category'] = df['value'].map({'low': 1, 'medium': 2, 'high': 3})</label></div>
<div class="option"><input type="radio" name="q30" id="q30o1" value="1"><label for="q30o1">df['category'] = df['value'].replace({'low': 1, 'medium': 2, 'high': 3})</label></div>
<div class="option"><input type="radio" name="q30" id="q30o2" value="2"><label for="q30o2">df['category'] = pd.Categorical(df['value']).map({'low': 1, 'medium': 2, 'high': 3})</label></div>
<div class="option"><input type="radio" name="q30" id="q30o3" value="3"><label for="q30o3">All of the above</label></div>
                </div>
                <div class="answer hidden">
                    <p><strong>Answer:</strong> All of the above</p>
                    <p><strong>Explanation:</strong> All methods can map values to new ones, though map() is generally preferred for dictionary-based mappings.</p>
                    
                </div>
                <button class="show-answer">Show Answer</button>
            </div>
        
        </div>
    </div>
    <script src="../quiz.js"></script>
</body>
</html>
    